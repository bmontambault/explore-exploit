import numpy as np
import GPy
import matplotlib.pyplot as plt


class GP:
    
    def __init__(self, kernel, npoints):
        self.kernel = kernel
        self.x=np.linspace(0,1,npoints)
        self.prior_K = kernel.K(self.x[:,None])
        self.observed_x = []
        self.observed_y = []
        
    
    def observe(self, x, y):
        self.observed_x.append(x)
        self.observed_y.append(y)
    
        
    def sample_prior(self):
        
        return np.random.multivariate_normal(np.ones(self.prior_K.shape[0])
                                             ,self.prior_K)
    
    def sample_posterior(self,samples):
        
        X = np.array(self.observed_x)[:,None]
        y = np.array(self.observed_y)[:,None]
        self.m = GPy.models.GPRegression(X, y, self.kernel, noise_var=10**-10)
        self.m.optimize_restarts(10, verbose=False)
        self.m.optimize()
        return self.m.posterior_samples_f(np.arange(len(self.x))[:,None],size=samples)
    
    

def generate_smooth(variance=1, lengthscale=1, npoints=100, nsamples=10,
                    init_points=5, plot_trials=0):
    
    kern = GPy.kern.RBF(1, variance=variance, lengthscale=lengthscale)
    gp = GP(kern, npoints)
    f = gp.sample_prior()
    x = np.random.choice(np.arange(npoints), init_points)
    y = f[x]
    for i in range(len(x)):
        gp.observe(x[i],y[i])
        
    for i in range(npoints-init_points):
        posterior_samples = gp.sample_posterior(nsamples)
        if i < plot_trials:
            plt.plot(posterior_samples)
            plt.plot(gp.observed_x, gp.observed_y, 'ko')
            plt.show()
        
        new_x = np.random.choice(np.array([i for i in range(posterior_samples.shape[0]) if i not in gp.observed_x]))
        new_y = np.random.choice(posterior_samples[new_x])
        gp.observe(new_x, new_y)
    
    idx = np.argsort(gp.observed_x)
    return np.array(gp.observed_y)[idx]